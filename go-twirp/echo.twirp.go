// Code generated by protoc-gen-twirp v5.5.0, DO NOT EDIT.
// source: echo.proto

/*
Package proto is a generated twirp stub package.
This code was generated with github.com/bilibili/twirp/protoc-gen-twirp v5.5.0.

It is generated from these files:
	echo.proto
*/
package proto

import bytes "bytes"
import strings "strings"
import context "context"
import fmt "fmt"
import strconv "strconv"
import errors "errors"
import ioutil "io/ioutil"
import http "net/http"

import jsonpb "github.com/golang/protobuf/jsonpb"
import proto "github.com/golang/protobuf/proto"
import twirp "github.com/bilibili/twirp"
import ctxsetters "github.com/bilibili/twirp/ctxsetters"

// If the request does not have any number filed, the strconv
// is not needed. However, there is no easy way to drop it.
var _ = strconv.IntSize

// ==============
// Echo Interface
// ==============

type Echo interface {
	Say(context.Context, *Request) (*Response, error)
}

// ====================
// Echo Protobuf Client
// ====================

type echoProtobufClient struct {
	client twirp.HTTPClient
	urls   [1]string
}

// NewEchoProtobufClient creates a Protobuf client that implements the Echo interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewEchoProtobufClient(addr string, client twirp.HTTPClient) Echo {
	prefix := addr + EchoPathPrefix
	urls := [1]string{
		prefix + "Say",
	}
	return &echoProtobufClient{
		client: client,
		urls:   urls,
	}
}

func (c *echoProtobufClient) Say(ctx context.Context, in *Request) (*Response, error) {
	ctx = ctxsetters.WithPackageName(ctx, "")
	ctx = ctxsetters.WithServiceName(ctx, "Echo")
	ctx = ctxsetters.WithMethodName(ctx, "Say")
	out := new(Response)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ================
// Echo JSON Client
// ================

type echoJSONClient struct {
	client twirp.HTTPClient
	urls   [1]string
}

// NewEchoJSONClient creates a JSON client that implements the Echo interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewEchoJSONClient(addr string, client twirp.HTTPClient) Echo {
	prefix := addr + EchoPathPrefix
	urls := [1]string{
		prefix + "Say",
	}
	return &echoJSONClient{
		client: client,
		urls:   urls,
	}
}

func (c *echoJSONClient) Say(ctx context.Context, in *Request) (*Response, error) {
	ctx = ctxsetters.WithPackageName(ctx, "")
	ctx = ctxsetters.WithServiceName(ctx, "Echo")
	ctx = ctxsetters.WithMethodName(ctx, "Say")
	out := new(Response)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ===================
// Echo Server Handler
// ===================

type echoServer struct {
	Echo
	hooks *twirp.ServerHooks
}

func NewEchoServer(svc Echo, hooks *twirp.ServerHooks) twirp.Server {
	return &echoServer{
		Echo:  svc,
		hooks: hooks,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *echoServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	s.hooks.WriteError(ctx, resp, err)
}

// badRouteError is used when the twirp server cannot route a request
func (s *echoServer) badRouteError(msg string, method, url string) twirp.Error {
	err := twirp.NewError(twirp.BadRoute, msg)
	err = err.WithMeta("twirp_invalid_route", method+" "+url)
	return err
}

func (s *echoServer) wrapErr(err error, msg string) error {
	return errors.New(msg + ": " + err.Error())
}

// EchoPathPrefix is used for all URL paths on a twirp Echo server.
// Requests are always: POST EchoPathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const EchoPathPrefix = "/twirp/Echo/"

func (s *echoServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithRequest(ctx, req)
	ctx = ctxsetters.WithPackageName(ctx, "")
	ctx = ctxsetters.WithServiceName(ctx, "Echo")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = s.hooks.CallRequestReceived(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" && !twirp.AllowGET(ctx) {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		err = s.badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}

	switch req.URL.Path {
	case "/twirp/Echo/Say":
		s.serveSay(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		err = s.badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}
}

func (s *echoServer) serveSay(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSayJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveSayProtobuf(ctx, resp, req)
	default:
		s.serveSayForm(ctx, resp, req)
	}
}

func (s *echoServer) serveSayJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "Say")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(Request)
	unmarshaler := jsonpb.Unmarshaler{AllowUnknownFields: true}
	if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	// Call service method
	var respContent *Response
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if r := recover(); r != nil {
				s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
				panic(r)
			}
		}()
		respContent, err = s.Echo.Say(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *Response and nil error while calling Say. nil responses are not supported"))
		return
	}

	ctx = ctxsetters.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		var buf bytes.Buffer
		marshaler := &jsonpb.Marshaler{OrigName: true, EmitDefaults: true}
		if err = marshaler.Marshal(&buf, respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		respBytes = buf.Bytes()
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = ctxsetters.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *echoServer) serveSayProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "Say")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(Request)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	// Call service method
	var respContent *Response
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if r := recover(); r != nil {
				s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
				panic(r)
			}
		}()
		respContent, err = s.Echo.Say(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *Response and nil error while calling Say. nil responses are not supported"))
		return
	}

	ctx = ctxsetters.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = ctxsetters.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *echoServer) serveSayForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "Say")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(Request)

	if v, ok := req.Form["text"]; ok {
		reqContent.Text = v[0]
	}

	// Call service method
	var respContent *Response
	func() {
		defer func() {
			// In case of a panic, serve a 500 error and then panic.
			if r := recover(); r != nil {
				s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
				panic(r)
			}
		}()
		respContent, err = s.Say(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *Response and nil error while calling Say. nil responses are not supported"))
		return
	}

	ctx = ctxsetters.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		var buf bytes.Buffer
		marshaler := &jsonpb.Marshaler{OrigName: true, EmitDefaults: true}
		if err = marshaler.Marshal(&buf, respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		respBytes = buf.Bytes()
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = ctxsetters.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *echoServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor0SHA1fd9d74670d7874b934b20ea3365d5295275152f, 0
}

func (s *echoServer) ProtocGenTwirpVersion() string {
	return "v5.5.0"
}

var twirpFileDescriptor0SHA1fd9d74670d7874b934b20ea3365d5295275152f = []byte{
	// 116 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4a, 0x4d, 0xce, 0xc8,
	0xd7, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x57, 0x92, 0xe5, 0x62, 0x0f, 0x4a, 0x2d, 0x2c, 0x4d, 0x2d,
	0x2e, 0x11, 0x12, 0xe2, 0x62, 0x29, 0x49, 0xad, 0x28, 0x91, 0x60, 0x54, 0x60, 0xd4, 0xe0, 0x0c,
	0x02, 0xb3, 0x95, 0xe4, 0xb8, 0x38, 0x82, 0x52, 0x8b, 0x0b, 0xf2, 0xf3, 0x8a, 0x53, 0xe1, 0xf2,
	0x4c, 0x08, 0x79, 0x23, 0x25, 0x2e, 0x16, 0xd7, 0xe4, 0x8c, 0x7c, 0x21, 0x29, 0x2e, 0xe6, 0xe0,
	0xc4, 0x4a, 0x21, 0x0e, 0x3d, 0xa8, 0x61, 0x52, 0x9c, 0x7a, 0x30, 0x7d, 0x4e, 0xec, 0x51, 0xac,
	0x60, 0xbb, 0x92, 0xd8, 0xc0, 0x94, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0xd3, 0x69, 0xb7, 0x0d,
	0x80, 0x00, 0x00, 0x00,
}
